module LCD(clk,rst,LCD_E,LCD_RW,LCD_RS,LCD_DATA);  \ninput clk;              //时钟信号,50Mhz  \ninput rst;              //复位信号,低电平进行复位  \noutput LCD_E;           //1602使能引脚，1时读取信息，1->0（下降沿）执行命令  \noutput LCD_RS;          //1602数据——H/命令——L  选择端  \noutput LCD_RW;          //1602写——L/读——H  选择端  \noutput [7:0] LCD_DATA;  //1602数据传输端口  \nwire LCD_E;  \nreg [8:0] count;  \nreg clk_div1;       //500个clk的周期，20ns*500=10us  \nreg clk_div2;       //1000个，20us  \nreg [7:0] count1;   //250个clk_div2的周期，20us*250=5000u=5ms  \nreg clk_buf;  \n//******************  \n//-----分频模块-----  \n//******************  \n\nalways @(posedge clk or negedge rst)  \nbegin  \n    if(!rst)    //rst=0  \n        count<=0;  \n    else  \n        begin  \n            if(count<250)        //2500  \n                begin  \n                    clk_div1<=0;  \n                    count<=count+1'b1;  \n                end  \n            else if(count>=500-1)        //5000  \n                count<=0;  \n            else  \n                begin  \n                    clk_div1<=1;  \n                    count<=count+1'b1;  \n                end               \n        end  \nend  \n\n\nalways @(posedge clk_div1 or negedge rst)  \nbegin  \n    if(!rst)  \n        clk_div2<=0;  \n    else  \n        clk_div2<=~clk_div2;  \nend  \nalways @(posedge clk_div2 or negedge rst)     \nbegin  \n    if(!rst)    //rst=0  \n        begin  \n            count1<=0;  \n            clk_buf<=0;      //  \n        end  \n    else  \n        begin  \n            if(count1<125)       //2500  \n                begin  \n                    clk_buf<=0;  \n                    count1<=count1+1'b1;  \n                end  \n            else if(count1>=250-1)       //5000  \n                count1<=0;  \n            else  \n                begin  \n                    clk_buf<=1;  \n                    count1<=count1+1'b1;  \n                end               \n        end  \nend  \nassign LCD_E=clk_buf;  \n  \n//**********************  \n//-----显示控制模块-----  \n//**********************  \nreg [4:0] state;        //当前状态寄存器  ,10个状态  \nreg [5:0] address;      //地址的位置，0~31,  \nreg [7:0] LCD_DATA;  \nreg LCD_RW,LCD_RS;  \nparameter     \n        IDLE             = 4'd0,    //空闲   \n        CLEAR            = 4'd1,  \n        SET_FUNCTION     = 4'd2,    //工作方式设置指令    \n        SWITCH_MODE      = 4'd3,     //开关控制指令    \n        SET_MODE         = 4'd4,    //输入方式设置    \n        SET_DDRAM1       = 4'd5,    //设定第一行DDRAM地址指令    \n        WRITE_RAM1       = 4'd6,    //向第一行写入的数码    \n        SET_DDRAM2       = 4'd7,    //设定第2行DDRAM地址指令    \n        WRITE_RAM2       = 4'd8,    //向第2行写入的数码    \n        SHIFT            = 4'd9,    //设定显示屏或光标移动方向指令  \n        STOP             = 4'd10;  \n              \nreg [7:0] Data_First [15:0];  \nreg [7:0] Data_Second [15:0];  \ninitial  \n    begin  \n        Data_First[0] =  " ";  \n        Data_First[1] =  "W";  \n        Data_First[2] =  "W";  \n        Data_First[3] =  "W";  \n        Data_First[4] =  ".";  \n        Data_First[5] =  "N";  \n        Data_First[6] =  "B";  \n        Data_First[7] =  "U";  \n        Data_First[8] =  ".";  \n        Data_First[9] =  "E";  \n        Data_First[10]=  "D";  \n        Data_First[11]=  "U";  \n        Data_First[12]=  ".";  \n        Data_First[13]=  "C";  \n        Data_First[14]=  "N";  \n        Data_First[15]=  " ";  \n          \n        Data_Second[0] =   " ";  \n        Data_Second[1] =   " ";  \n        Data_Second[2] =   " ";  \n        Data_Second[3] =   "X";  \n        Data_Second[4] =   "I";  \n        Data_Second[5] =   "N";  \n        Data_Second[6] =   "-";  \n        Data_Second[7] =   "X";  \n        Data_Second[8] =   "I";  \n        Data_Second[9] =   "-";  \n        Data_Second[10]=   "4";  \n        Data_Second[11]=   "1";  \n        Data_Second[12]=   "1";  \n        Data_Second[13]=   " ";  \n        Data_Second[14]=   " ";  \n        Data_Second[15]=   " ";  \n  \n\n    end  \n//-----状态控制-----  \nalways @(posedge clk_buf or negedge rst)        // clk_div1 clk_buf  \nbegin  \n    if(!rst)  \n        begin  \n            state<=IDLE;  \n            address<=6'd0;  \n            LCD_DATA<=8'b0000_0000;  \n            LCD_RS<=0;  \n            LCD_RW<=0;  \n        end  \n    else  \n        begin  \n            case(state)  \n                IDLE:       //空闲状态  \n                            begin  \n                                LCD_DATA<=8'bzzzz_zzzz;      //8'bzzzz_zzzz  \n                                state<=CLEAR;  \n                            end  \n                CLEAR:      //清屏指令  \n                                begin  \n                                    LCD_RS<=0;  \n                                    LCD_RW<=0;  \n                                    LCD_DATA<=8'b0000_0001;  //指令  \n                                    state<=SET_FUNCTION;                           \n                                end  \n                SET_FUNCTION:       //工作方式设置  \n                                begin  \n                                    LCD_RS<=0;  \n                                    LCD_RW<=0;  \n                                    LCD_DATA<=8'b0011_1100;      //38h  \n                                    //第4位DL：0=数据总线为4位；1=数据总线为8位★★★  \n                                    //第3位N：0=显示1行；1=显示2行★★★    \n                                    //第2位F：0=5×7点阵/每字符；1=5×10点阵/每字符★★★  \n                                    state<=SWITCH_MODE;        \n                                end  \n                SWITCH_MODE:        //显示开关控制指令  \n                                begin  \n                                    LCD_RS<=0;  \n                                    LCD_RW<=0;  \n                                    LCD_DATA<=8'b0000_1111;      //0Fh  \n                                    //第2位D：0=显示功能关；1=显示功能开★★★  \n                                    //第1位C：0=无光标；1=有光标★★★    \n                                    //第0位B：1=光标闪烁； 0=光标不闪烁★★★  \n                                    state<=SET_MODE;  \n                                end  \n                SET_MODE:       //设定显示屏或光标移动方向指令    \n                                begin  \n                                    LCD_RS<=0;  \n                                    LCD_RW<=0;  \n                                    LCD_DATA<=8'b0000_0110;  //06h  \n                                    //第1位N：0=读或者写一个字符后，地址指针-1，光标-1  \n                                    //        1=读或者写一个字符后，地址指针+1，光标+1★★★  \n                                    //第0位S：0=当写一个字符，整屏显示不移动★★★  \n                                    //        1=当写一个字符，整屏显示左移（N=1）或者右移（N=0）,以得到光标不移动而屏幕移动的效果  \n                                    state<=SHIFT;   \n                                end               \n                SHIFT:      //设定显示屏或光标移动方向指令    \n                                begin  \n                                    LCD_RS<=0;  \n                                    LCD_RW<=0;  \n                                    LCD_DATA<=8'b0001_0100;    \n                                    //第3位S/C；第2位R/L  \n                                    //     S/C   R/L     设定情况    \n                                    //      0      0      光标左移1格，且地址指针值减1    \n                                    //      0      1      光标右移1格，且地址指针值加1  ★★★  \n                                    //      1      0      显示器上字符全部左移一格，但光标不动    \n                                    //      1      1      显示器上字符全部右移一格，但光标不动  \n                                    state<=SET_DDRAM1;   \n                                end  \n                SET_DDRAM1:     //设定第一行DDRAM地址指令  \n                                begin    \n                                    LCD_RS<=0;  \n                                    LCD_RW<=0;  \n                              \n                //-----写入第一行显示起始地址：-----   \n                //  1   2  3  4   5   6   7  8  9  10  11  12  13  14  15  16  \n                // 00  01 02  03  04  05 06 07 08  09  0A  0B  0C  0D  0E  0F   第一行  \n                                    LCD_DATA<=8'h80+8'd0; //第一行第1个位置   \n                                      \n                                    address<=2'd0;  \n                                    state<=WRITE_RAM1;   \n//                                  Data_First_Buf<=Data_First;    \n                                end  \n                WRITE_RAM1:     //向第一行写入的数码  \n                                begin  \n                                    if(address<=15)          //表示写第一行  \n                                        begin  \n                                            LCD_RS<=1;  \n                                            LCD_RW<=0;  \n                                            LCD_DATA<=Data_First[address];  \n//                                          Data_First_Buf<=(Data_First_Buf<<8);   //左移  \n                                            address<=address+1'b1;  \n                                            state<=WRITE_RAM1;  \n                                        end  \n                                    else  \n                                        begin  \n                                            LCD_RS<=0;  \n                                            LCD_RW<=0;  \n                                            LCD_DATA<=8'h80+address;  \n                                            state<=SET_DDRAM2;  \n                                        end  \n                                end  \n                SET_DDRAM2:     //设定第2行DDRAM地址指令  \n                                begin    \n                                    LCD_RS<=0;  \n                                    LCD_RW<=0;  \n                              \n                //-----写入第2行显示起始地址：-----   \n                //  1   2  3  4   5   6   7  8  9  10  11  12  13  14  15  16  \n                // 40  41 42  43  44  45 46 47 48  49  4A  4B  4C  4D  4E  4F   第二行  \n                                    LCD_DATA<=8'hC0+8'd0; //第2行第1个位置    \n                              \n                                    state<=WRITE_RAM2;   \n//                                  Data_Second_Buf<=Data_Second;    \n                                    address<=6'd0;  \n                                end  \n                WRITE_RAM2:     //向第2行写入的数码  \n                            begin  \n                                if(address<=15)          //表示写第一行  \n                                        begin  \n                                            LCD_RS<=1;  \n                                            LCD_RW<=0;  \n                                            LCD_DATA<=Data_Second[address];  \n//                                          Data_Second_Buf<=(Data_Second_Buf<<8);   \n                                            address<=address+1'b1;  \n                                            state<=WRITE_RAM2;  \n                                        end  \n                                    else  \n                                        begin  \n                                            LCD_RS<=0;  \n                                            LCD_RW<=0;  \n                                            LCD_DATA<=8'hC0+address;  \n                                            state<=STOP;  \n                                        end  \n                            end  \n                STOP:         \n                            begin  \n                                            state<=STOP;  \n                                            address<=6'd0;  \n                                            LCD_RW<=1;  \n                            end  \n                default:  \n                            state<=CLEAR;  \n            endcase               \n        end  \nend  \n      \nendmodule